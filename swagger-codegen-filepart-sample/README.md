# Swagger Codegen FilePart Sample Project

âš ï¸ **IMPORTANT**: This project demonstrates that custom Mustache parameter templates **DO NOT WORK** with Swagger Codegen 3.x Spring generator. See [TEST_RESULTS.md](TEST_RESULTS.md) for detailed findings.

This is a sample Spring Boot WebFlux project that attempts to use **custom Mustache templates** with Swagger Codegen 3.x to generate `Mono<FilePart>` instead of `MultipartFile` for reactive file uploads. The test confirms this approach **does not work**, and provides a working manual controller solution instead.

## ğŸ“‹ Table of Contents

- [Problem Statement](#problem-statement)
- [Solution](#solution)
- [Project Structure](#project-structure)
- [How to Run](#how-to-run)
- [Understanding the Fix](#understanding-the-fix)
- [Known Limitations](#known-limitations)
- [Alternative Approaches](#alternative-approaches)

## ğŸ¯ Problem Statement

**Default Behavior**: Swagger Codegen 3.x generates blocking `MultipartFile` for file uploads, even when configured with `<reactive>true</reactive>`:

```java
// âŒ Generated by default (blocking)
@RequestPart MultipartFile file
```

**Desired Behavior**: For Spring WebFlux reactive applications, we need reactive `Mono<FilePart>`:

```java
// âœ… What we want (reactive)
@RequestPart Mono<FilePart> file
```

## ğŸ’¡ Solution Attempted

This project demonstrates an **UNSUCCESSFUL attempt** to use custom Mustache templates to override Swagger Codegen's default generation behavior.

### âŒ Test Result: Custom Templates DO NOT WORK

**What Was Tried**:
- Created custom parameter templates in `src/main/resources/swagger-templates/`
- Configured `<templateDirectory>` in pom.xml
- Enabled `<reactive>true</reactive>` mode

**What Happened**:
- Swagger Codegen **ignored** the custom parameter templates
- Generated code still uses `MultipartFile` instead of `Mono<FilePart>`
- Templates are not loaded by the Spring generator

See [TEST_RESULTS.md](TEST_RESULTS.md) for complete analysis.

### âœ… Working Solution: Manual Controller

The project provides a **working manual controller** implementation:

```java
@RestController
public class FilesController {
    @PostMapping("/files")
    public Mono<ResponseEntity<FileUploadResponse>> uploadFile(
        @RequestPart Mono<FilePart> file,  // âœ… Reactive type
        ...
    ) { ... }
}
```

### Custom Templates Included (Non-Functional)

Located in `src/main/resources/swagger-templates/` (for reference only):

1. **formParams.mustache** - Attempted file upload parameter template
2. **queryParams.mustache** - Query parameters
3. **pathParams.mustache** - Path variables
4. **headerParams.mustache** - Header parameters
5. **bodyParams.mustache** - Request body parameters

**Status**: These templates are NOT used by Swagger Codegen 3.x

## ğŸ“ Project Structure

```
swagger-codegen-filepart-sample/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main/
â”‚   â”‚   â”œâ”€â”€ java/com/example/
â”‚   â”‚   â”‚   â”œâ”€â”€ Application.java                 # Spring Boot main class
â”‚   â”‚   â”‚   â””â”€â”€ controller/
â”‚   â”‚   â”‚       â””â”€â”€ FilesController.java         # âœ… Reactive controller implementation
â”‚   â”‚   â””â”€â”€ resources/
â”‚   â”‚       â”œâ”€â”€ api.yaml                         # OpenAPI 3.0 specification
â”‚   â”‚       â”œâ”€â”€ application.yml                  # Spring Boot configuration
â”‚   â”‚       â””â”€â”€ swagger-templates/               # â­ Custom Mustache templates
â”‚   â”‚           â”œâ”€â”€ formParams.mustache          # File upload parameter template
â”‚   â”‚           â”œâ”€â”€ queryParams.mustache
â”‚   â”‚           â”œâ”€â”€ pathParams.mustache
â”‚   â”‚           â”œâ”€â”€ headerParams.mustache
â”‚   â”‚           â””â”€â”€ bodyParams.mustache
â”œâ”€â”€ target/generated-sources/                    # Generated code
â”‚   â””â”€â”€ src/main/java/com/example/
â”‚       â”œâ”€â”€ api/FilesApi.java                    # Generated interface
â”‚       â””â”€â”€ model/                               # Generated model classes
â”œâ”€â”€ pom.xml                                      # Maven configuration
â””â”€â”€ README.md
```

## ğŸš€ How to Run

### Prerequisites

- Java 11 or higher
- Maven 3.6+

### Step 1: Generate Code

```bash
mvn clean generate-sources
```

This will:
1. Read `src/main/resources/api.yaml`
2. Use custom templates from `src/main/resources/swagger-templates/`
3. Generate API interfaces and model classes in `target/generated-sources/`

### Step 2: Build Project

```bash
mvn clean package
```

### Step 3: Run Application

```bash
mvn spring-boot:run
```

The application will start on `http://localhost:8080`

### Step 4: Test File Upload

```bash
# Test upload endpoint (reactive)
curl -X POST http://localhost:8080/files \
  -F "file=@test-file.txt" \
  -F "fileName=test-file.txt" \
  -F "uploadedBy=user123" \
  -F 'metadata={"tags":["test","demo"]}' \
  -F "tags=important,document"

# Test get metadata endpoint
curl http://localhost:8080/files/{file-id-from-upload-response}
```

## ğŸ” Understanding the Fix

### The Challenge

Swagger Codegen 3.x doesn't properly support reactive file uploads out of the box. Even with `<reactive>true</reactive>`, it generates:

```java
// Generated interface (still uses MultipartFile)
public interface FilesApi {
    ResponseEntity<FileUploadResponse> uploadFile(
        @RequestPart MultipartFile file,  // âŒ Blocking type
        ...
    );
}
```

### The Solution Approach

This project demonstrates **two complementary approaches**:

#### 1. Custom Mustache Templates (Attempted)
- Location: `src/main/resources/swagger-templates/`
- Purpose: Override default parameter generation
- **Current Status**: âš ï¸ Limited support in Swagger Codegen 3.x

Swagger Codegen 3.x has limitations with custom parameter templates. The templates are included to show the approach, but they don't fully work for the Spring generator.

#### 2. Manual Controller Implementation (Working Solution)
- Location: `src/main/java/com/example/controller/FilesController.java`
- Purpose: Implement the interface manually with reactive types

```java
@RestController
public class FilesController {

    @PostMapping("/files")
    public Mono<ResponseEntity<FileUploadResponse>> uploadFile(
        @RequestPart Mono<FilePart> file,  // âœ… Reactive type
        ...
    ) {
        return file.flatMap(filePart -> {
            // Reactive file processing
            String filename = filePart.filename();
            long size = filePart.headers().getContentLength();

            // Save file, process, etc.
            return Mono.just(ResponseEntity.ok(response));
        });
    }
}
```

### Why Manual Implementation Works Better

1. **Full Control**: You have complete control over parameter types
2. **Reactive Types**: Use `Mono<FilePart>` instead of `MultipartFile`
3. **WebFlux Features**: Access to `ServerWebExchange`, reactive streams
4. **Model Reuse**: Still use generated model classes (FileUploadResponse, FileMetadata)

## âš ï¸ Known Limitations

### Swagger Codegen 3.x Custom Template Limitations

While this project includes custom Mustache templates, Swagger Codegen 3.x has several limitations:

1. **Parameter Templates Not Fully Supported**: The Spring generator doesn't fully respect custom parameter templates like `formParams.mustache`

2. **Template Override Scope**: Only certain templates can be overridden effectively:
   - âœ… **Model templates**: Work well
   - âš ï¸ **API templates**: Partial support
   - âŒ **Parameter templates**: Limited/no support

3. **Reactive Mode Incomplete**: Even with `<reactive>true</reactive>`:
   - Return types become `Mono<ResponseEntity<T>>` âœ…
   - Parameter types remain `MultipartFile` âŒ

### Current Generated Code

The generated `FilesApi.java` interface still shows:

```java
// target/generated-sources/.../FilesApi.java
public interface FilesApi {
    default ResponseEntity<FileUploadResponse> uploadFile(
        @RequestPart MultipartFile file,  // âŒ Still MultipartFile
        ...
    ) { ... }
}
```

### Recommended Approach

**For Production Use**:

1. **Use OpenAPI Generator** (instead of Swagger Codegen)
   - Better reactive support
   - Actively maintained
   - Properly generates `FilePart` with reactive mode

2. **Generate Models Only** (if using Swagger Codegen)
   - Configure: `<generateApis>false</generateApis>`
   - Write controllers manually
   - Reuse generated model classes

3. **Manual Controllers** (this project's approach)
   - Full control over reactive types
   - Use generated models
   - Company-approved approach

## ğŸ”„ Alternative Approaches

### Option 1: Switch to OpenAPI Generator (Recommended)

Replace Swagger Codegen with OpenAPI Generator in `pom.xml`:

```xml
<plugin>
    <groupId>org.openapitools</groupId>
    <artifactId>openapi-generator-maven-plugin</artifactId>
    <version>7.10.0</version>
    <configuration>
        <inputSpec>${project.basedir}/src/main/resources/api.yaml</inputSpec>
        <generatorName>spring</generatorName>
        <library>spring-boot</library>
        <configOptions>
            <reactive>true</reactive>  <!-- Properly generates FilePart -->
            <interfaceOnly>true</interfaceOnly>
        </configOptions>
    </configuration>
</plugin>
```

**Result**: Generates `Flux<Part>` or `Mono<FilePart>` automatically âœ…

### Option 2: Generate Models Only

Configure Swagger Codegen to generate only model classes:

```xml
<configuration>
    <generateApis>false</generateApis>
    <generateModels>true</generateModels>
    <generateSupportingFiles>false</generateSupportingFiles>
</configuration>
```

Then write controllers manually (like `FilesController.java` in this project).

### Option 3: Post-Processing Generated Code

Use Maven plugins to post-process generated code:
- maven-replacer-plugin
- maven-antrun-plugin

Replace `MultipartFile` with `Mono<FilePart>` after generation.

## ğŸ“š Key Files Reference

| File | Purpose | Status |
|------|---------|--------|
| `src/main/resources/api.yaml` | OpenAPI 3.0 specification | âœ… Working |
| `src/main/resources/swagger-templates/*.mustache` | Custom templates | âš ï¸ Limited support |
| `src/main/java/com/example/controller/FilesController.java` | Manual reactive controller | âœ… Working (recommended) |
| `target/generated-sources/.../FilesApi.java` | Generated interface | âš ï¸ Uses MultipartFile |
| `target/generated-sources/.../model/*.java` | Generated models | âœ… Working |
| `pom.xml` | Maven configuration | âœ… Configured |

## ğŸ¯ Conclusions

### What Works

âœ… Generated model classes (`FileUploadResponse`, `FileMetadata`, etc.)
âœ… Manual controller implementation with reactive types
âœ… Spring WebFlux reactive file handling
âœ… Complete reactive application

### What Doesn't Work

âŒ Custom Mustache templates for parameters in Swagger Codegen 3.x
âŒ Automatic `FilePart` generation from Swagger Codegen
âŒ Full reactive code generation from Swagger Codegen

### Recommendations

1. **Short Term**: Use manual controllers (like this project)
   - Generate models only
   - Write reactive controllers manually
   - Full control over types

2. **Long Term**: Migrate to OpenAPI Generator
   - Better reactive support
   - Actively maintained
   - Generates correct reactive types

3. **Best Practices**:
   - Keep OpenAPI spec as source of truth
   - Generate models automatically
   - Write controllers following company standards
   - Use reactive types (`Mono<FilePart>`) for WebFlux

## ğŸ¤ Contributing

This is a sample/reference project demonstrating reactive file upload approaches with Swagger Codegen and Spring WebFlux.

## ğŸ“ License

MIT License

---

**Created**: 2025-11-28
**Status**: âœ… Working Sample
**Purpose**: Demonstrate reactive file upload with Swagger Codegen limitations and solutions
