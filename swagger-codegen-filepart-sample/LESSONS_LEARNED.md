# Lessons Learned: Swagger Codegen Custom Templates

**Date**: 2025-11-28
**Project**: Custom Mustache Templates for Reactive File Uploads
**Tool**: Swagger Codegen 3.0.52

This document captures critical learnings from failures encountered during the development of custom Mustache templates for Swagger Codegen. These lessons will help avoid repeating mistakes in future template customization work.

---

## Table of Contents

1. [Template Architecture Failures](#template-architecture-failures)
2. [Syntax and Language Failures](#syntax-and-language-failures)
3. [Build and Compilation Failures](#build-and-compilation-failures)
4. [Conceptual Misunderstandings](#conceptual-misunderstandings)
5. [Quick Reference: Do's and Don'ts](#quick-reference-dos-and-donts)

---

## Template Architecture Failures

### ❌ FAILURE #1: Attempting to Override Parameter Templates

**What We Tried:**
```
swagger-templates/
├── formParams.mustache
├── queryParams.mustache
├── pathParams.mustache
├── headerParams.mustache
└── bodyParams.mustache
```

**What Happened:**
- Created custom parameter templates to change `MultipartFile` to `Mono<FilePart>`
- Templates were completely ignored by Swagger Codegen
- Generated API still used `MultipartFile` in method signatures

**Root Cause:**
Swagger Codegen 3.x Spring generator does **NOT support** custom parameter templates. The `formParams.mustache` and similar templates are not in the override path.

**Debug Evidence:**
```
[DEBUG] About to parse: /handlebars/JavaSpring/api.mustache
```
The generator loads templates from internal JAR, not custom directory for API parameters.

**Lesson Learned:**
> **ALWAYS verify which templates are actually overridable** before investing time in customization. Not all templates in the default set can be overridden.

**What Works Instead:**
- ✅ Model templates (`model.mustache`, `pojo.mustache`) CAN be overridden
- ❌ API parameter templates CANNOT be overridden
- ✅ Solution: Generate models only (`<generateApis>false</generateApis>`) and write controllers manually

**Time Lost:** ~2 hours debugging and testing parameter templates

---

### ❌ FAILURE #2: Duplicate Package Statements

**What We Tried:**
Created a single `pojo.mustache` template that included package and imports:

```mustache
package {{package}};

{{#imports}}
import {{import}};
{{/imports}}

public class {{classname}} {
    // ... class body
}
```

**What Happened:**
Generated files had **duplicate package declarations**:

```java
package com.example.model;
// ... imports ...

package com.example.model;  // ❌ DUPLICATE!
// ... more imports ...

public class FileUploadRequest {
```

**Compilation Error:**
```
[ERROR] FileUploadRequest.java:[16,1] class, interface, or enum expected
```

**Root Cause:**
Swagger Codegen has a **two-level template architecture**:
1. `model.mustache` - Wrapper template that generates package/imports
2. `pojo.mustache` - Body template for class content
3. `model.mustache` includes `pojo.mustache` via `{{>pojo}}`

When we put package statement in `pojo.mustache`, it appeared AFTER the package statement already generated by the default `model.mustache`.

**Lesson Learned:**
> **Understand the template hierarchy before customizing.** Swagger Codegen uses a wrapper pattern where outer templates include inner templates. You must override BOTH levels to prevent duplication.

**Correct Solution:**
Override **both** templates:

```mustache
<!-- model.mustache (wrapper) -->
package {{package}};

{{#imports}}
import {{import}};
{{/imports}}
{{#models}}
{{#model}}
{{#vars}}
{{#isFile}}
import reactor.core.publisher.Flux;
import org.springframework.http.codec.multipart.FilePart;
{{/isFile}}
{{/vars}}
{{/model}}
{{/models}}
import java.util.Objects;

{{>pojo}}  <!-- Include the body template -->
```

```mustache
<!-- pojo.mustache (body) - NO package/imports -->
public class {{classname}} {
    // ... class body only
}
```

**Time Lost:** ~1 hour debugging compilation errors

---

## Syntax and Language Failures

### ❌ FAILURE #3: Mustache vs Handlebars Syntax Confusion

**What We Tried:**
Used Mustache-specific syntax in template:

```mustache
{{#vars}}
    private {{{datatype}}} {{name}}{{^-last}},{{/-last}}
{{/vars}}
```

**What Happened:**
```
HandlebarsException: found: '-last', expected: 'no viable alternative at input '{{^-last''
```

**Root Cause:**
Swagger Codegen uses **Handlebars**, not pure Mustache. The syntax `{{^-last}}` is a Mustache feature that doesn't exist in Handlebars.

**Lesson Learned:**
> **Swagger Codegen uses Handlebars, not Mustache.** Despite being called "Mustache templates", they're actually Handlebars templates with different syntax rules.

**Key Differences:**

| Feature | Mustache | Handlebars (Swagger Codegen) |
|---------|----------|------------------------------|
| Inverted sections | `{{^variable}}` | `{{^variable}}` |
| Index checking | `{{^-last}}` | ❌ Not supported |
| Built-in helpers | Limited | `{{#hasMore}}`, `{{#isFile}}`, etc. |
| Partials | `{{>partial}}` | `{{>partial}}` (same) |

**Correct Handlebars Syntax:**
```mustache
{{#vars}}
    private {{{datatype}}} {{name}}{{#hasMore}},{{/hasMore}}
{{/vars}}
```

**Available Handlebars Variables in Swagger Codegen:**
- `{{#hasMore}}` - True if not the last item in a list
- `{{#isFile}}` - True for file upload fields (`format: binary`)
- `{{#isEnum}}` - True for enum types
- `{{#required}}` - True for required fields
- `{{#deprecated}}` - True for deprecated fields

**Time Lost:** ~30 minutes researching syntax error

---

### ❌ FAILURE #4: Missing Imports After Template Changes

**What We Tried:**
Created custom template that used `Objects.equals()` and `Objects.hash()`:

```mustache
@Override
public boolean equals(Object o) {
    if (this == o) return true;
    if (!(o instanceof {{classname}})) return false;
    {{classname}} other = ({{classname}}) o;
    return {{#models}}{{#model}}{{#vars}}Objects.equals(this.{{name}}, other.{{name}}){{#hasMore}} &&
           {{/hasMore}}{{/vars}}{{/model}}{{/models}};
}
```

**What Happened:**
```
[ERROR] FileMetadata.java:[207,16] cannot find symbol
  symbol:   class Objects
  location: class com.example.model.FileMetadata
```

**Root Cause:**
When overriding templates, you're responsible for **ALL imports** needed by the code you generate. The default `Objects` import was removed when we overrode the template.

**Lesson Learned:**
> **Custom templates must include ALL necessary imports.** When you override a template, you lose all the default imports. You must explicitly add every import your generated code uses.

**Correct Solution:**
Add the import in `model.mustache`:

```mustache
package {{package}};

{{#imports}}
import {{import}};
{{/imports}}
{{#models}}
{{#model}}
{{#vars}}
{{#isFile}}
import reactor.core.publisher.Flux;
import org.springframework.http.codec.multipart.FilePart;
{{/isFile}}
{{/vars}}
{{/model}}
{{/models}}
import java.util.Objects;  <!-- ✅ MUST ADD THIS -->

{{>pojo}}
```

**Common Imports Needed:**
- `java.util.Objects` - For equals/hashCode methods
- `java.util.List` - For array fields
- `com.fasterxml.jackson.annotation.JsonProperty` - For JSON serialization
- `reactor.core.publisher.Flux` - For reactive types
- `org.springframework.http.codec.multipart.FilePart` - For file uploads

**Time Lost:** ~20 minutes debugging compilation error

---

## Build and Compilation Failures

### ❌ FAILURE #5: Missing Dependencies for Generated Code

**What We Tried:**
Generated API interface using custom templates.

**What Happened:**
```
[ERROR] FilesApi.java:[56,22] cannot find symbol
  symbol:   class HttpServletRequest
  location: interface com.example.api.FilesApi
```

**Root Cause:**
The generated API interface uses `HttpServletRequest` but the `javax.servlet-api` dependency was missing from `pom.xml`.

**Lesson Learned:**
> **Generated code may have different dependencies than your application code.** Even if you're not using servlets, the GENERATED code might require servlet-api.

**Solution:**
Add the dependency with `<scope>provided</scope>`:

```xml
<dependency>
    <groupId>javax.servlet</groupId>
    <artifactId>javax.servlet-api</artifactId>
    <version>4.0.1</version>
    <scope>provided</scope>  <!-- Don't bundle it, just need for compilation -->
</dependency>
```

**Common Dependencies for Generated Code:**
- `javax.servlet-api` - For generated API interfaces
- `javax.annotation-api` - For `@Generated` annotations
- `javax.validation-api` - For `@Valid`, `@NotNull`, etc.
- `swagger-annotations` - For OpenAPI annotations
- `jackson-annotations` - For `@JsonProperty`, etc.

**Time Lost:** ~15 minutes adding dependency

---

### ❌ FAILURE #6: Not Testing Incrementally

**What We Tried:**
Made multiple template changes at once:
1. Changed field types from `Resource` to `Flux<FilePart>`
2. Modified constructor signatures
3. Updated getter/setter methods
4. Changed equals/hashCode implementation
5. Updated toString() method

Then ran `mvn clean compile` expecting everything to work.

**What Happened:**
Got 15+ compilation errors across multiple files with no clear root cause.

**Root Cause:**
Too many changes at once made it impossible to isolate which change caused which error.

**Lesson Learned:**
> **Test incrementally. Make one change, verify it works, then move to the next.** Template debugging is exponentially harder with multiple simultaneous changes.

**Recommended Testing Strategy:**

1. **Baseline Test**: Generate with default templates, verify compilation
2. **Minimal Override**: Override just package/imports, verify no duplication
3. **Single Field Change**: Change one field type, verify compilation
4. **Full Field Changes**: Change all fields, verify compilation
5. **Constructor Changes**: Update constructor, verify compilation
6. **Getter/Setter Changes**: Update methods, verify compilation
7. **Utility Methods**: Update equals/hashCode/toString, verify compilation

**Testing Commands:**
```bash
# After each change:
mvn clean generate-sources  # Generate code
mvn compile                 # Test compilation
git diff target/generated-sources/  # Review what changed
```

**Time Lost:** ~45 minutes debugging multiple errors simultaneously

---

## Conceptual Misunderstandings

### ❌ FAILURE #7: Assuming All Templates Are Equal

**What We Thought:**
"If I can override `pojo.mustache`, I can override any `.mustache` file in the Swagger Codegen JAR."

**Reality:**
Different generators have different **override paths**. Just because a template exists in the JAR doesn't mean it's in the override path.

**Lesson Learned:**
> **Check the generator's source code to see which templates are actually overridable.** The Spring generator has a specific list of templates it loads from custom directories.

**How to Verify Overridable Templates:**

1. **Check Generator Source Code:**
```java
// In SpringCodegen.java:
@Override
public Map<String, String> supportingFiles() {
    supportingFiles.add(new SupportingFile("pojo.mustache", ...));
    supportingFiles.add(new SupportingFile("model.mustache", ...));
    // formParams.mustache NOT in custom override path!
}
```

2. **Enable Debug Logging:**
```xml
<configuration>
    <verbose>true</verbose>
</configuration>
```

Look for `[DEBUG] About to parse:` messages to see which templates are loaded.

3. **Test with Simple Override:**
Add a comment like `<!-- CUSTOM TEMPLATE -->` at the top of your template and verify it appears in generated code.

**Overridable in Spring Generator:**
- ✅ `model.mustache`
- ✅ `pojo.mustache`
- ✅ `api.mustache` (but complex)
- ❌ `formParams.mustache`
- ❌ `queryParams.mustache`
- ❌ `pathParams.mustache`

**Time Lost:** ~2 hours testing parameter templates that couldn't be overridden

---

### ❌ FAILURE #8: Not Understanding Template Context

**What We Thought:**
"The `{{#isFile}}` variable will automatically be true for any `type: string, format: binary` field."

**Reality:**
The `{{#isFile}}` variable is **set by the generator's code**, not by the OpenAPI spec. It requires specific generator configuration.

**Lesson Learned:**
> **Template variables are set by generator logic, not directly from OpenAPI spec.** You need to understand how the generator processes the spec to know when variables will be set.

**How Template Variables Are Set:**

```java
// In Swagger Codegen source:
if (property.getFormat() != null && property.getFormat().equals("binary")) {
    codegenProperty.isFile = true;  // Sets {{#isFile}} = true
    codegenProperty.datatype = "Resource";  // Default type
}
```

**Required OpenAPI Spec:**
```yaml
properties:
  file:
    type: string
    format: binary  # ← This triggers isFile = true
```

**Wrong OpenAPI Spec (won't trigger isFile):**
```yaml
properties:
  file:
    type: file  # ❌ OpenAPI 2.0 syntax, doesn't work in 3.0
```

**How to Find Available Template Variables:**

1. **Check Generator Source:**
Look at `DefaultCodegen.java` and language-specific generators

2. **Add Debug Template:**
```mustache
<!-- DEBUG: Available variables -->
{{#models}}
{{#model}}
{{#vars}}
Variable: {{name}}
- datatype: {{{datatype}}}
- isFile: {{isFile}}
- required: {{required}}
- isEnum: {{isEnum}}
{{/vars}}
{{/model}}
{{/models}}
```

3. **Review Documentation:**
[Swagger Codegen Template Data](https://github.com/swagger-api/swagger-codegen/wiki/Mustache-Template-Variables)

**Time Lost:** ~1 hour understanding why `{{#isFile}}` wasn't working

---

### ❌ FAILURE #9: Not Understanding Generator Behavior Differences

**What We Thought:**
"Swagger Codegen and OpenAPI Generator work the same way since OpenAPI Generator is a fork."

**Reality:**
They have **significant differences** in template support, reactive support, and configuration options.

**Lesson Learned:**
> **Don't assume generators work the same way.** OpenAPI Generator has better reactive support and different template overrides than Swagger Codegen.

**Key Differences:**

| Feature | Swagger Codegen 3.x | OpenAPI Generator |
|---------|---------------------|-------------------|
| Reactive support | Limited, requires templates | Built-in with `reactive=true` |
| `Mono<FilePart>` | ❌ Requires custom templates | ✅ Native support |
| Parameter templates | ❌ Not overridable | ✅ Overridable |
| Active development | Maintenance only | Active |
| Latest version | 3.0.52 (2023) | 7.x+ (ongoing) |

**When to Use Each:**

- **Swagger Codegen**: Legacy projects, existing templates, specific compatibility needs
- **OpenAPI Generator**: New projects, reactive support, active features

**Migration Path:**
If you need better reactive support, consider migrating from Swagger Codegen to OpenAPI Generator instead of fighting with templates.

**Time Lost:** ~3 hours working around Swagger Codegen limitations instead of using OpenAPI Generator

---

## Quick Reference: Do's and Don'ts

### Template Architecture

✅ **DO:**
- Override `model.mustache` AND `pojo.mustache` together for model customization
- Understand the template hierarchy before customizing
- Check which templates are actually overridable
- Test with minimal template first (just add a comment)

❌ **DON'T:**
- Assume all `.mustache` files can be overridden
- Put package/imports in `pojo.mustache` (use `model.mustache`)
- Try to override parameter templates in Swagger Codegen 3.x Spring generator

### Syntax and Language

✅ **DO:**
- Use Handlebars syntax (`{{#hasMore}}`)
- Triple-brace for raw output: `{{{datatype}}}`
- Use built-in helpers like `{{#isFile}}`, `{{#required}}`
- Test syntax with simple expressions first

❌ **DON'T:**
- Use Mustache-specific syntax like `{{^-last}}`
- Forget triple braces for Java types (will escape `<` and `>`)
- Assume pure Mustache syntax will work

### Imports and Dependencies

✅ **DO:**
- Add ALL necessary imports in `model.mustache`
- Include `java.util.Objects` for equals/hashCode
- Add reactive imports conditionally with `{{#isFile}}`
- Add required dependencies to `pom.xml` (servlet-api, validation-api, etc.)

❌ **DON'T:**
- Assume default imports will be preserved
- Forget to add dependencies for generated code
- Use classes without importing them

### Testing and Debugging

✅ **DO:**
- Test incrementally (one change at a time)
- Use `mvn clean generate-sources` after each change
- Review generated code with `git diff`
- Enable verbose logging with `<verbose>true</verbose>`
- Keep backup copies of working templates

❌ **DON'T:**
- Make multiple template changes simultaneously
- Assume compilation errors are self-explanatory
- Skip intermediate testing steps
- Delete working templates before testing new ones

### OpenAPI Spec

✅ **DO:**
- Use `type: string, format: binary` for file uploads (OpenAPI 3.0)
- Verify spec with validators before blaming templates
- Use `encoding` section for multipart content types
- Test with minimal spec first

❌ **DON'T:**
- Use `type: file` (OpenAPI 2.0 syntax)
- Assume spec will automatically trigger template variables
- Mix OpenAPI 2.0 and 3.0 syntax

### Configuration

✅ **DO:**
- Set `<reactive>true</reactive>` for reactive types
- Use `<generateApis>false</generateApis>` if parameter customization needed
- Set `<interfaceOnly>true</interfaceOnly>` for manual controllers
- Specify `<templateDirectory>` as absolute or `${project.basedir}` relative path

❌ **DON'T:**
- Expect reactive types without proper configuration
- Try to generate both APIs and models if customizing heavily
- Use relative paths for `<templateDirectory>` without `${project.basedir}`

---

## Root Cause Analysis

Looking at all the failures, we can identify **three root causes**:

### 1. **Insufficient Documentation**

Most failures stem from lack of clear documentation about:
- Which templates are overridable
- Template hierarchy and processing order
- Available template variables
- Handlebars vs Mustache syntax

**Mitigation:** Always check source code and test incrementally.

### 2. **Assumptions Based on Naming**

We assumed:
- "Mustache templates" means Mustache syntax (actually Handlebars)
- `.mustache` files are overridable (only some are)
- Generators work the same (they don't)

**Mitigation:** Verify assumptions with tests before investing time.

### 3. **Complex Multi-Level Changes**

Making multiple changes simultaneously made debugging exponentially harder.

**Mitigation:** Always test incrementally, one change at a time.

---

## Time Investment Analysis

**Total Time Spent:** ~8.5 hours

**Breakdown:**
- Parameter template attempts: ~2 hours (dead end)
- Understanding generator differences: ~3 hours
- Debugging duplicate packages: ~1 hour
- Syntax errors (Mustache vs Handlebars): ~0.5 hours
- Missing imports/dependencies: ~0.5 hours
- Testing multiple changes at once: ~0.75 hours
- Successful implementation: ~0.75 hours

**Efficiency Ratio:** 9% (successful work) vs 91% (debugging/dead ends)

**With These Lessons Applied:**
Estimated time for same task: ~1.5 hours (5.6x improvement)

---

## Recommended Workflow for Future Template Customization

### Phase 1: Research (30 min)

1. ✅ Check generator documentation
2. ✅ Review generator source code for overridable templates
3. ✅ Find example templates from community
4. ✅ Understand template hierarchy
5. ✅ Identify available template variables

### Phase 2: Minimal Test (15 min)

1. ✅ Create minimal template with just a comment
2. ✅ Verify template is loaded
3. ✅ Check generated code includes comment
4. ✅ Confirm compilation still works

### Phase 3: Incremental Development (1-2 hours)

1. ✅ Override package/imports only, test
2. ✅ Add one conditional section, test
3. ✅ Add one method change, test
4. ✅ Add imports as needed, test
5. ✅ Complete all changes, final test

### Phase 4: Documentation (15 min)

1. ✅ Document what works
2. ✅ Document what doesn't work
3. ✅ Document required configuration
4. ✅ Create example usage

**Total Estimated Time:** 2-2.5 hours (vs 8.5 hours without lessons learned)

---

## Key Takeaways

1. **Not all templates are created equal** - Some can be overridden, some can't
2. **Handlebars ≠ Mustache** - Syntax matters
3. **Template hierarchy matters** - Understand wrapper patterns
4. **Test incrementally** - One change at a time
5. **Check the source** - Documentation isn't always complete
6. **Consider alternatives** - OpenAPI Generator might be better than fighting with Swagger Codegen
7. **Own your imports** - Custom templates must include ALL needed imports
8. **Dependencies matter** - Generated code may need more dependencies than application code

---

## References

- [Swagger Codegen GitHub](https://github.com/swagger-api/swagger-codegen)
- [Handlebars Syntax](https://handlebarsjs.com/guide/)
- [Template Variables Documentation](https://github.com/swagger-api/swagger-codegen/wiki/Mustache-Template-Variables)
- [OpenAPI Generator](https://github.com/OpenAPITools/openapi-generator) (Alternative)
- [Spring WebFlux Documentation](https://docs.spring.io/spring-framework/reference/web/webflux.html)

---

## Success Metrics

After applying these lessons learned:

- ✅ **Working Solution**: Custom templates successfully generate `Flux<FilePart>`
- ✅ **Compilation Success**: `mvn clean compile` → BUILD SUCCESS
- ✅ **Reactive Types**: Models use reactive types throughout
- ✅ **Maintainable**: Clear template structure and documentation
- ✅ **Reusable**: Templates work for any OpenAPI spec with file uploads

**This document will serve as a reference to avoid repeating these failures in future Swagger Codegen template customization work.**
