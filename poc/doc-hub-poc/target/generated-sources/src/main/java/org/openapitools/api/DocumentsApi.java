/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech) (6.6.0).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
package org.openapitools.api;

import org.openapitools.model.DocumentDetailsNode;
import org.openapitools.model.ErrorResponse;
import org.openapitools.model.InlineResponse200;
import org.openapitools.model.MetadataNode;
import java.util.UUID;
import org.openapitools.model.XRequestorType;
import io.swagger.v3.oas.annotations.ExternalDocumentation;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.Parameters;
import io.swagger.v3.oas.annotations.media.ArraySchema;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import io.swagger.v3.oas.annotations.enums.ParameterIn;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import org.springframework.http.codec.multipart.Part;

import javax.validation.Valid;
import javax.validation.constraints.*;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import javax.annotation.Generated;

@Generated(value = "org.openapitools.codegen.languages.SpringCodegen", date = "2025-11-24T18:34:04.945806200-08:00[America/Los_Angeles]")
@Validated
@Tag(name = "Document Management", description = "the Document Management API")
public interface DocumentsApi {

    /**
     * POST /documents : Upload a document
     * Uploads a document for storage.    The files currently are not scanned for viruses on the server end. It&#39;ll be part of a future implementation. Currently it&#39;ll be the responibility of the client.      For text based files, if Byte Order Mark (BOM) is present, it will be preserved. It is the responsibility of the client to correclty handle the BOM at the time of retrieval. 
     *
     * @param xVersion Api version (required)
     * @param xCorrelationId Correlation ID for request tracing (required)
     * @param xRequestorId Id of the requestor (required)
     * @param xRequestorType Type of the requestor (required)
     * @param documentType - \\\&quot;PaymentLetter\\\&quot; - \\\&quot;StatementInsert\\\&quot; - \\\&quot;AdverseActionNotice\\\&quot; - \\\&quot;ChangeInTermsNotice\\\&quot; - \\\&quot;AnnualFeeNotice\\\&quot; - \\\&quot;PrivacyNotice\\\&quot; - \\\&quot;NachaLetter\\\&quot; - \\\&quot;DelinquencyNotice\\\&quot; - \\\&quot;EsignInformation\\\&quot; - \\\&quot;CustomerLetter\\\&quot; - \\\&quot;FraudLetter\\\&quot; - \\\&quot;Statement\\\&quot; - \\\&quot;ReturnedPaymentLetter\\\&quot; - \\\&quot;FreeCLILetter\\\&quot; - \\\&quot;PaidCLILetter\\\&quot; - \\\&quot;CardholderAgreement\\\&quot; - \\\&quot;CreditProtectionLetter\\\&quot; - \\\&quot;BalanceTransferLetter\\\&quot; - \\\&quot;MiscellaneousLetter\\\&quot; - \\\&quot;AutopayLetter\\\&quot;  (required)
     * @param createdBy Identifies the user or system that created the document entry. (required)
     * @param content The actual body or data of the document (e.g., PDF, text, or JSON). (required)
     * @param metadata Each document type has its own set of required metadata so it can be properly indexed. Required fields and expected format can be retrieved using GET /templates. (required)
     * @param templateId Unique identifier referencing the document generation template used. (optional)
     * @param referenceKey External identifier linking the document to a specific business entity or transaction. (optional)
     * @param referenceKeyType Specifies what the reference key represents (e.g., statement, customer, account). (optional)
     * @param accountKey Unique key representing the account associated with the document. (optional)
     * @param customerKey Unique identifier for the customer related to the document. (optional)
     * @param category Defines the grouping or classification of the document for organizational purposes. (optional)
     * @param fileName Name of the document file stored in the system. (optional)
     * @param activeStartDate Epoch time in seconds  (optional)
     * @param activeEndDate Epoch time in seconds  (optional)
     * @param threadId Identifier used to trace or group related document processing threads or events. (optional)
     * @param correlationId ID used to track and correlate document-related requests or operations across systems. (optional)
     * @return OK (status code 200)
     *         or Bad Request (status code 400)
     *         or Unauthorized access to an endpoint (status code 401)
     *         or Not Found (status code 404)
     *         or Cannot be processed. Antivirus scan failed. (status code 409)
     *         or Internal Server Error (status code 500)
     *         or Service Unavailable (status code 503)
     */
    @Operation(
        operationId = "addDocument",
        summary = "Upload a document",
        description = "Uploads a document for storage.    The files currently are not scanned for viruses on the server end. It'll be part of a future implementation. Currently it'll be the responibility of the client.      For text based files, if Byte Order Mark (BOM) is present, it will be preserved. It is the responsibility of the client to correclty handle the BOM at the time of retrieval. ",
        tags = { "Document Management" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = InlineResponse200.class))
            }),
            @ApiResponse(responseCode = "400", description = "Bad Request", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorResponse.class))
            }),
            @ApiResponse(responseCode = "401", description = "Unauthorized access to an endpoint", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorResponse.class))
            }),
            @ApiResponse(responseCode = "404", description = "Not Found", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorResponse.class))
            }),
            @ApiResponse(responseCode = "409", description = "Cannot be processed. Antivirus scan failed.", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorResponse.class))
            }),
            @ApiResponse(responseCode = "500", description = "Internal Server Error", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorResponse.class))
            }),
            @ApiResponse(responseCode = "503", description = "Service Unavailable", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = "/documents",
        produces = { "application/json" },
        consumes = { "multipart/form-data" }
    )
    default Mono<ResponseEntity<InlineResponse200>> addDocument(
        @NotNull @Parameter(name = "X-version", description = "Api version", required = true, in = ParameterIn.HEADER) @RequestHeader(value = "X-version", required = true, defaultValue = "1") Integer xVersion,
        @NotNull @Size(max = 36) @Parameter(name = "X-correlation-id", description = "Correlation ID for request tracing", required = true, in = ParameterIn.HEADER) @RequestHeader(value = "X-correlation-id", required = true) String xCorrelationId,
        @NotNull @Parameter(name = "X-requestor-id", description = "Id of the requestor", required = true, in = ParameterIn.HEADER) @RequestHeader(value = "X-requestor-id", required = true) UUID xRequestorId,
        @NotNull @Parameter(name = "X-requestor-type", description = "Type of the requestor", required = true, in = ParameterIn.HEADER) @RequestHeader(value = "X-requestor-type", required = true) XRequestorType xRequestorType,
        @Parameter(name = "documentType", description = "- \\\"PaymentLetter\\\" - \\\"StatementInsert\\\" - \\\"AdverseActionNotice\\\" - \\\"ChangeInTermsNotice\\\" - \\\"AnnualFeeNotice\\\" - \\\"PrivacyNotice\\\" - \\\"NachaLetter\\\" - \\\"DelinquencyNotice\\\" - \\\"EsignInformation\\\" - \\\"CustomerLetter\\\" - \\\"FraudLetter\\\" - \\\"Statement\\\" - \\\"ReturnedPaymentLetter\\\" - \\\"FreeCLILetter\\\" - \\\"PaidCLILetter\\\" - \\\"CardholderAgreement\\\" - \\\"CreditProtectionLetter\\\" - \\\"BalanceTransferLetter\\\" - \\\"MiscellaneousLetter\\\" - \\\"AutopayLetter\\\" ", required = true) @Valid @RequestParam(value = "documentType", required = true) String documentType,
        @Parameter(name = "createdBy", description = "Identifies the user or system that created the document entry.", required = true) @Valid @RequestParam(value = "createdBy", required = true) UUID createdBy,
        @Parameter(name = "content", description = "The actual body or data of the document (e.g., PDF, text, or JSON).", required = true) @RequestPart(value = "content", required = true) Flux<Part> content,
        @Parameter(name = "metadata", description = "Each document type has its own set of required metadata so it can be properly indexed. Required fields and expected format can be retrieved using GET /templates.", required = true) @Valid @RequestPart(value = "metadata", required = true) List<@Valid MetadataNode> metadata,
        @Parameter(name = "templateId", description = "Unique identifier referencing the document generation template used.") @Valid @RequestParam(value = "templateId", required = false) UUID templateId,
        @Parameter(name = "referenceKey", description = "External identifier linking the document to a specific business entity or transaction.") @Valid @RequestParam(value = "referenceKey", required = false) String referenceKey,
        @Parameter(name = "referenceKeyType", description = "Specifies what the reference key represents (e.g., statement, customer, account).") @Valid @RequestParam(value = "referenceKeyType", required = false) String referenceKeyType,
        @Parameter(name = "accountKey", description = "Unique key representing the account associated with the document.") @Valid @RequestParam(value = "accountKey", required = false) UUID accountKey,
        @Parameter(name = "customerKey", description = "Unique identifier for the customer related to the document.") @Valid @RequestParam(value = "customerKey", required = false) UUID customerKey,
        @Parameter(name = "category", description = "Defines the grouping or classification of the document for organizational purposes.") @Valid @RequestParam(value = "category", required = false) String category,
        @Parameter(name = "fileName", description = "Name of the document file stored in the system.") @Valid @RequestParam(value = "fileName", required = false) String fileName,
        @Parameter(name = "activeStartDate", description = "Epoch time in seconds ") @Valid @RequestParam(value = "activeStartDate", required = false) Long activeStartDate,
        @Parameter(name = "activeEndDate", description = "Epoch time in seconds ") @Valid @RequestParam(value = "activeEndDate", required = false) Long activeEndDate,
        @Parameter(name = "threadId", description = "Identifier used to trace or group related document processing threads or events.") @Valid @RequestParam(value = "threadId", required = false) UUID threadId,
        @Parameter(name = "correlationId", description = "ID used to track and correlate document-related requests or operations across systems.") @Valid @RequestParam(value = "correlationId", required = false) UUID correlationId,
        @Parameter(hidden = true) final ServerWebExchange exchange
    ) {
        Mono<Void> result = Mono.empty();
        exchange.getResponse().setStatusCode(HttpStatus.NOT_IMPLEMENTED);
        for (MediaType mediaType : exchange.getRequest().getHeaders().getAccept()) {
            if (mediaType.isCompatibleWith(MediaType.valueOf("application/json"))) {
                String exampleString = "{ \"id\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\" }";
                result = ApiUtil.getExampleResponse(exchange, mediaType, exampleString);
                break;
            }
        }
        return result.then(Mono.empty());

    }


    /**
     * DELETE /documents/{documentId} : Deletes the document identified by \&quot;documentId\&quot; 
     *
     * @param xVersion Api version (required)
     * @param xCorrelationId Correlation ID for request tracing (required)
     * @param xRequestorId Id of the requestor (required)
     * @param xRequestorType Type of the requestor (required)
     * @param documentId  (required)
     * @return Successful operation (status code 204)
     *         or Unauthorized access to an endpoint (status code 401)
     *         or Forbidden (status code 403)
     *         or Not Found (status code 404)
     *         or Service Unavailable (status code 503)
     */
    @Operation(
        operationId = "documentDelete",
        summary = "Deletes the document identified by \"documentId\" ",
        tags = { "Document Management" },
        responses = {
            @ApiResponse(responseCode = "204", description = "Successful operation"),
            @ApiResponse(responseCode = "401", description = "Unauthorized access to an endpoint", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorResponse.class))
            }),
            @ApiResponse(responseCode = "403", description = "Forbidden", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorResponse.class))
            }),
            @ApiResponse(responseCode = "404", description = "Not Found", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorResponse.class))
            }),
            @ApiResponse(responseCode = "503", description = "Service Unavailable", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.DELETE,
        value = "/documents/{documentId}",
        produces = { "application/json" }
    )
    default Mono<ResponseEntity<Void>> documentDelete(
        @NotNull @Parameter(name = "X-version", description = "Api version", required = true, in = ParameterIn.HEADER) @RequestHeader(value = "X-version", required = true, defaultValue = "1") Integer xVersion,
        @NotNull @Size(max = 36) @Parameter(name = "X-correlation-id", description = "Correlation ID for request tracing", required = true, in = ParameterIn.HEADER) @RequestHeader(value = "X-correlation-id", required = true) String xCorrelationId,
        @NotNull @Parameter(name = "X-requestor-id", description = "Id of the requestor", required = true, in = ParameterIn.HEADER) @RequestHeader(value = "X-requestor-id", required = true) UUID xRequestorId,
        @NotNull @Parameter(name = "X-requestorType", description = "Type of the requestor", required = true, in = ParameterIn.HEADER) @RequestHeader(value = "X-requestorType", required = true) XRequestorType xRequestorType,
        @Size(max = 500) @Parameter(name = "documentId", description = "", required = true, in = ParameterIn.PATH) @PathVariable("documentId") String documentId,
        @Parameter(hidden = true) final ServerWebExchange exchange
    ) {
        Mono<Void> result = Mono.empty();
        exchange.getResponse().setStatusCode(HttpStatus.NOT_IMPLEMENTED);
        return result.then(Mono.empty());

    }


    /**
     * GET /documents/{documentId} : Downloads the document identified by \&quot;documentId\&quot; 
     *
     * @param xVersion Api version (required)
     * @param xCorrelationId Correlation ID for request tracing (required)
     * @param documentId  (required)
     * @param xRequestorType Type of the requestor (required)
     * @param xRequestorId Id of the requestor (required)
     * @return OK (status code 200)
     *         or Unauthorized access to an endpoint (status code 401)
     *         or Forbidden (status code 403)
     *         or Not Found (status code 404)
     *         or Service Unavailable (status code 503)
     */
    @Operation(
        operationId = "documentDownload",
        summary = "Downloads the document identified by \"documentId\" ",
        tags = { "Document Management" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "application/octet-stream", schema = @Schema(implementation = org.springframework.core.io.Resource.class)),
                @Content(mediaType = "application/json", schema = @Schema(implementation = org.springframework.core.io.Resource.class))
            }),
            @ApiResponse(responseCode = "401", description = "Unauthorized access to an endpoint", content = {
                @Content(mediaType = "application/octet-stream", schema = @Schema(implementation = ErrorResponse.class)),
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorResponse.class))
            }),
            @ApiResponse(responseCode = "403", description = "Forbidden", content = {
                @Content(mediaType = "application/octet-stream", schema = @Schema(implementation = ErrorResponse.class)),
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorResponse.class))
            }),
            @ApiResponse(responseCode = "404", description = "Not Found", content = {
                @Content(mediaType = "application/octet-stream", schema = @Schema(implementation = ErrorResponse.class)),
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorResponse.class))
            }),
            @ApiResponse(responseCode = "503", description = "Service Unavailable", content = {
                @Content(mediaType = "application/octet-stream", schema = @Schema(implementation = ErrorResponse.class)),
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/documents/{documentId}",
        produces = { "application/octet-stream", "application/json" }
    )
    default Mono<ResponseEntity<org.springframework.core.io.Resource>> documentDownload(
        @NotNull @Parameter(name = "X-version", description = "Api version", required = true, in = ParameterIn.HEADER) @RequestHeader(value = "X-version", required = true, defaultValue = "1") Integer xVersion,
        @NotNull @Size(max = 36) @Parameter(name = "X-correlation-id", description = "Correlation ID for request tracing", required = true, in = ParameterIn.HEADER) @RequestHeader(value = "X-correlation-id", required = true) String xCorrelationId,
        @Size(max = 500) @Parameter(name = "documentId", description = "", required = true, in = ParameterIn.PATH) @PathVariable("documentId") String documentId,
        @NotNull @Parameter(name = "X-requestor-type", description = "Type of the requestor", required = true, in = ParameterIn.HEADER) @RequestHeader(value = "X-requestor-type", required = true) XRequestorType xRequestorType,
        @NotNull @Parameter(name = "X-requestor-id", description = "Id of the requestor", required = true, in = ParameterIn.HEADER) @RequestHeader(value = "X-requestor-id", required = true) UUID xRequestorId,
        @Parameter(hidden = true) final ServerWebExchange exchange
    ) {
        Mono<Void> result = Mono.empty();
        exchange.getResponse().setStatusCode(HttpStatus.NOT_IMPLEMENTED);
        return result.then(Mono.empty());

    }


    /**
     * GET /documents/{documentId}/metadata : Retreives the metadata for the document identified by documentId
     *
     * @param xVersion Api version (required)
     * @param xCorrelationId Correlation ID for request tracing (required)
     * @param documentId  (required)
     * @param xRequestorType Type of the requestor (required)
     * @param xRequestorId Id of the requestor (required)
     * @param includeDownloadUrl Indicates if ECMS document download url to be included in response (optional, default to false)
     * @return OK (status code 200)
     *         or Unauthorized access to endpoint (status code 401)
     *         or Forbidden (status code 403)
     *         or Not Found (status code 404)
     *         or Service Unavailable (status code 503)
     */
    @Operation(
        operationId = "documentMetadata",
        summary = "Retreives the metadata for the document identified by documentId",
        tags = { "Document Management" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = DocumentDetailsNode.class))
            }),
            @ApiResponse(responseCode = "401", description = "Unauthorized access to endpoint", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorResponse.class))
            }),
            @ApiResponse(responseCode = "403", description = "Forbidden", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorResponse.class))
            }),
            @ApiResponse(responseCode = "404", description = "Not Found", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorResponse.class))
            }),
            @ApiResponse(responseCode = "503", description = "Service Unavailable", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/documents/{documentId}/metadata",
        produces = { "application/json" }
    )
    default Mono<ResponseEntity<DocumentDetailsNode>> documentMetadata(
        @NotNull @Parameter(name = "X-version", description = "Api version", required = true, in = ParameterIn.HEADER) @RequestHeader(value = "X-version", required = true, defaultValue = "1") Integer xVersion,
        @NotNull @Size(max = 36) @Parameter(name = "X-correlation-id", description = "Correlation ID for request tracing", required = true, in = ParameterIn.HEADER) @RequestHeader(value = "X-correlation-id", required = true) String xCorrelationId,
        @Size(max = 500) @Parameter(name = "documentId", description = "", required = true, in = ParameterIn.PATH) @PathVariable("documentId") String documentId,
        @NotNull @Parameter(name = "X-requestor-type", description = "Type of the requestor", required = true, in = ParameterIn.HEADER) @RequestHeader(value = "X-requestor-type", required = true) XRequestorType xRequestorType,
        @NotNull @Parameter(name = "X-requestor-id", description = "Id of the requestor", required = true, in = ParameterIn.HEADER) @RequestHeader(value = "X-requestor-id", required = true) UUID xRequestorId,
        @Parameter(name = "includeDownloadUrl", description = "Indicates if ECMS document download url to be included in response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeDownloadUrl", required = false, defaultValue = "false") Boolean includeDownloadUrl,
        @Parameter(hidden = true) final ServerWebExchange exchange
    ) {
        Mono<Void> result = Mono.empty();
        exchange.getResponse().setStatusCode(HttpStatus.NOT_IMPLEMENTED);
        for (MediaType mediaType : exchange.getRequest().getHeaders().getAccept()) {
            if (mediaType.isCompatibleWith(MediaType.valueOf("application/json"))) {
                String exampleString = "{ \"lineOfBusiness\" : \"CREDIT_CARD\", \"lastClientDownload\" : \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\", \"metadata\" : [ { \"key\" : \"accountId\", \"value\" : \"3fa85f64-5717-4562-b3fc-2c963f66afa6\" }, { \"key\" : \"issueDate\", \"value\" : \"2025-01-01\" }, { \"key\" : \"customerId\", \"value\" : \"3fa85f64-5717-4562-b3fc-2c963f66a78\" }, { \"key\" : \"htmlLettername\", \"value\" : \"FF083\" } ], \"documentType\" : \"PaymentLetter\", \"_links\" : { \"download\" : { \"responseTypes\" : [ \"application/pdf\", \"application/octet-stream\" ], \"rel\" : \"download\", \"href\" : \"/documents/eyJ21pbWFnZVBh2dGgiOi4IiL\", \"type\" : \"GET\", \"title\" : \"Download this document\" }, \"delete\" : { \"rel\" : \"delete\", \"href\" : \"/documents/eyJ21pbWFnZVBh2dGgiOi4IiL\", \"type\" : \"DELETE\", \"title\" : \"Delete this document\" } }, \"displayName\" : \"2024_PRIVACY_POLICY\", \"description\" : \"2024_PRIVACY_POLICY\", \"mimeType\" : \"application/pdf\", \"sizeInMb\" : 1, \"documentId\" : \"documentId\", \"category\" : \"PaymentConfirmationNotice\", \"datePosted\" : 1740523843, \"lastDownloaded\" : 1740523843 }";
                result = ApiUtil.getExampleResponse(exchange, mediaType, exampleString);
                break;
            }
        }
        return result.then(Mono.empty());

    }

}
